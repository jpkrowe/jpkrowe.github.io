---
layout: post
title: "Week 6-7: Testing with LAMMPS and NAMD and integrating into WESTPA"
date: 2025-07-23 00:00:00 +0100
description: Week 6-7 testing with LAMMPS and NAMD and integrating into WESTPA.
# img: gsocheader.png # Add image post (optional)
tags: [GSOC, Molecular dynamics] # add tag
---

These past two weeks I have focused on two different tasks: testing the trajectory streaming scripts with LAMMPS and NAMD, and integrating the scripts into WESTPA.

# Testing with LAMMPS and NAMD

The previous post focused on using GROMACS to run the MD simulation. In the previous script, GROMACS was instructed to use port 0, which allowed the operating system to assign an available port. In order to use the same approach with LAMMPS and NAMD, we need to check that these MD engines support the same "port 0 trick". When we instruct NAMD to use port 0, it throws an error: `'IMDport' was set to 0 but it should be positive`. Clearly, we have to be more careful with NAMD and provide a specific port number. In the case of LAMMPS, it throws a similar error: `ERROR: Illegal fix imd parameter: port < 1024`. This means that for both LAMMPS and NAMD we will have to pass the port number explicitly. Since we are already starting the simulation from within a Python script, this can be performed quite easily by using a simple python function:

```python
def get_available_port():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(('', 0))  # Bind to an ephemeral port using the port 0 trick
    port = sock.getsockname()[1]
    sock.close()
    return port
```

This port number can be passed to the MD engine when the `subprocess.Popen` command is called. This solution works for both LAMMPS and NAMD. There is a slight issue here as the port number is not immediately bound to the simulation, leading to a potential point of failure if another process binds to the port before the simulation starts. This is most likely going to be a problem when many (thousands) of simulations are being started simultaneously by WESTPA. In my testing, I have not encountered this issue yet, but I have not tested with a very large number of simulations. In LAMMPS, there is quite a nice potential solution. LAMMPS allows the use of python code to define variables within the input script. Importantly, the code is only executed when the variable is used, which means that the simulation should bind the port immediately after being assigned it. This can be done by doing the following within the LAMMPS input script.

First the variable needs to be defined:
```plaintext
variable portfunc python get_port
python get_port input 0 return v_portfunc format i here """
def get_port():
    import socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(('', 0))  # Bind to an ephemeral port
    port = sock.getsockname()[1]
    sock.close()
    return port
"""
```

Then the variable can be used in the `fix imd` command:
```text
fix 2 all imd ${portfunc} version 3 unwrap off nowait off
```
The port number will be assigned when the `fix imd` command is executed, ensuring that the port is bound to the simulation. This is quite a nice solution, but requires building LAMMPS with the `PYTHON` package enabled.

# Integrating scripts into WESTPA
After developing the trajectory streaming scripts, the next step was to integrate them further into WESTPA. The goal was to reduce the code the user needs to supply. These changes are being tracked in the following two pull requests: [WESTPA pull request #501](https://github.com/westpa/westpa/pull/501) and [westpa-traj-streaming pull request #2](https://github.com/jpkrowe/westpa-traj-streaming/pull/2). 

Withing WESTPA tools a new file was created `traj_streaming.py` which contains the `TrajectoryStreaming` class. 